{% extends "layout.html" %}
{% block title %}Voxel Ray Tracer{% endblock %}
{% block description %}OpenGL Ray Tracing Tutorial{% endblock %}
{% block  keywords %}ray tracing, ray casting, opengl, voxel, realtime ray tracing, opengl ray tracing, voxel ray tracing, ray tracing tutorial, ray tracing c++{% endblock %}
{% block content %}
<h1 align="center">Writing a Realtime 3D Voxel Ray Tracer Using OpenGL Shaders</h1>
<h3>Contents</h3>
<ol>
    <li><a href="#intro">Introduction</a></li>
    <li><a href="#prereq">Prerequisites</a>
        <ul>
            <li><a href="#windows">Windows (Visual Studio IDE)</a></li>
        </ul>
    </li>
    <li><a href="#setup">Basic Setup</a></li>
    <li><a href="#shader">Shader Setup</a></li>
    <li><a href="#send">Sending voxel data</a></li>
    <li>Ray casting: DDA vs Marching</li>
    <li>Conclusion</li>
</ol>
<h4><a id="intro"></a>Introduction</h4>
<p class="comment">/* This guide is intended to expand and build upon <a href="https://lodev.org/cgtutor/raycasting.html">Lode Vandevenne's tutorial on ray casting</a> to support full ray tracing with the use of GPU computation */</p>
<p>A crucial distinction: </p>
<ol>
    <li><u>Ray casting</u> is the use of ray-surface intersection tests across a <u>single side</u> of a screen (i.e. in one line of pixels) to render models. It allows you to create a 3D perspective from a 2D map.</li>
    <li><u>Ray tracing</u> is the use of ray-surface intersection tests on <u>every pixel</u> of the screen to render models. It can create a 3D perspective from a 3D map.</li>
</ol>
<p>Consequently, ray casting limits you to a fixed height (hence why wolf3D for example does not allow for jumping, multiple heights, or changing the camera pitch).
    Ray tracing on the other hand can allow you to do all this with the use of a map of voxels (cubes arranged in a three-dimensional grid) instead of a 2D grid of squares.
</p>
<p>In this tutorial we will be creating a full, realtime ray tracer that draws everything in the map we give it and handles some basic forward lighting. Since we're using
    OpenGL, we can use shaders to take advantage of the GPU to make ray tracing extremely fast using the many parallel cores available in modern graphics cards. There are also further optimisations
    we will make based on the fact we are creating a voxel renderer which handles cubic models only rather than any possible model. At the end, we will explore how this can be extended to
    efficiently render many other geometries.
</p>
<h4><a id="prereq"></a>Prerequisites</h4>
<p>We will be using the following dependancies in this guide and <u>it is up to you to set them up or use an equivalent
    if you are on a platform that isn't described in this guide</u>:</p>
<ul>
    <li>OpenGL 4.30 (Check GPU compatibility)</li>
    <li><a href="https://glad.dav1d.de/">GLAD</a> (OpenGL extension library)</li>
    <li><a href="https://www.libsdl.org/download-2.0.php">SDL2</a> (OpenGL development library)</li>
    <li><a href="https://github.com/g-truc/glm/releases">GLM</a> (Vector/Matrix mathematics library)</li>
</ul>
<p>You should have some experience with OpenGL otherwise you WILL struggle to understand some of this guide. If you do not and are only interested in how ray casting is done then feel free to skip straight to the ray casting section</p>
<h5><a id="windows"></a>Windows (Visual Studio IDE)</h5>
<p><u>Step 1</u>: Use the links above to download the required development binaries for our dependancies. The options selected for our 
    version of GLAD are shown below:
</p>
<img src="{{ url_for('static',filename='files/GLAD.png') }}" />
<p><u>Step 2</u> Create two folders called 'include' and 'lib' in your project directory. These will be used for 
    included headers and library files from our dependancies. 
</p>
<p><u>Step 3</u>: Extract the contents of the 'include' folder inside your SDL2 zip into our project 'include' folder (it's best to 
    extract to a subfolder inside 'include' that you could call 'SDL2'). 
    Similarly, extract the 'glm', 'glad' and 'KHR' folders from their zips into 'include'. It should be obvious by now that
    'lib' folders should be extracted into our project's 'lib' folder. Now, run your project once to generate a folder for 
    the compiled binaries. In this folder, you should cut your 'SDL2.dll' file from our 'lib' folder to the folder
    where compiled binaries will reside. This is usually called 'Debug' or 'Release' depending on your configuration.
</p>
<p><u>Step 4</u>: Inside the glad zip, make sure you extract 'glad.c' from 'src' and into your project folder. Then
make sure to add it to your project through Visual Studio. This is absolutely necessary for GLAD to function.</p>
<p><u>Step 5</u> Setup project configs by doing the following after right-clicking your project and opening properties:
 <br>   - Go to C++ --> General --> Additional Include Directories --> add './include'
 <br>   - Go to Linker --> General --> Additional Library Directories --> add './lib'
 <br>   - Go to Linker --> Input --> Additional Dependancies --> add:
 <br>   (separate by lines): opengl32.lib, SDL2.lib, SDL2main.lib
</p>
<h4><a id="setup"></a>Basic Setup</h4>
<p>To begin with, we start with the relevant includes and main function for our program.</p>
<pre><code class="language-c language-cpp">// OpenGL support libraries
#include &lt;glad/glad.h&gt;
#include &lt;SDL2/SDL.h&gt;

// For vector/matrix maths
#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/type_ptr.hpp&gt;

// For compiling shaders
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;

int main(int argc, char* argv[])
{
    return EXIT_SUCCESS;
}
</code></pre>
<p>We will now setup SDL with a window and OpenGL context as well as an 'event' variable for polling events (e.g. key presses and mouse movements). Alongside this, we define the OpenGL version
    we are using as 4.3 and the number of bits assigned for each attribute. In addition, we make sure we are using double buffering to avoid drawing to the screen while it is being displayed.
</p>
<pre><code class="language-c language-cpp">SDL_Window* window = nullptr;
SDL_GLContext glContext;
SDL_Event event;

// Define window width and height in pixels
#define W_WIDTH 1280
#define W_HEIGHT 720

int main(int argc, char* argv[])
{
    // ========== SDL2 BOILERPLATE ==========

	// Initialisation
	SDL_Init(SDL_INIT_EVERYTHING);
	SDL_GL_SetAttribute(SDL_GL_ACCELERATED_VISUAL, 1);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 4);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);
	SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8);
	SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);
	SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8);
	SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8);
	SDL_GL_SetAttribute(SDL_GL_BUFFER_SIZE, 32);
	SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);

	// Create window
    window = SDL_CreateWindow("Voxel Ray Tracer", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 
                              W_WIDTH, W_HEIGHT, SDL_WINDOW_OPENGL);
	glContext = SDL_GL_CreateContext(window);

	// Capture mouse
	SDL_SetRelativeMouseMode(SDL_TRUE);

	// GLAD: load all OpenGL function pointers
	if (!gladLoadGLLoader((GLADloadproc)SDL_GL_GetProcAddress))
		std::cout << "Failed to initialize GLAD" << std::endl;

	atexit(SDL_Quit);

	glViewport(0, 0, W_WIDTH, W_HEIGHT);
	glDisable(GL_DEPTH_TEST);
    glDisable(GL_CULL_FACE);
    

    return EXIT_SUCCESS;
}
</code></pre>
<p>It should be clear that since we are going to be doing ray tracing, the traditional OpenGL method of creating meshes will not work since this isn't ray tracing at all.
    Instead, we'll be working on individual pixels. This means we have to create a single quad that encompasses the entire viewport. It will then be through this quad that
    we can make calculations based on individual pixels through the fragment shader. The following code comes after our SDL2/OpenGL boilerplate and sets up our quad. 
    It should be quite self-explanatory if you're familiar with OpenGL.
</p>
<pre><code class="language-c language-cpp">// Single quad used to draw all pixels
float vertices[] = {
    1.0, 1.0, 0.0,  // Top right
    1.0, -1.0, 0.0,  // Bottom right
    -1.0, -1.0, 0.0,  // Bottom left
    -1.0, 1.0, 0.0   // Top left 
};
unsigned int indices[] = {
    0, 1, 3,  // First Triangle
    1, 2, 3   // Second Triangle
};

unsigned int VBO, VAO, EBO;
glGenVertexArrays(1, &VAO);
glGenBuffers(1, &VBO);
glGenBuffers(1, &EBO);

glBindVertexArray(VAO);

glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);

glBindBuffer(GL_ARRAY_BUFFER, 0);

glBindVertexArray(0);
</code></pre>
<p>Next, continuing within our main function after our previous code, we setup a simple game loop with event handling so our ray tracer runs continously and is capable of responding to inputs in order to move or rotate the camera.
    The loop includes some variables used to track the time passed between frames as a way of both knowing the framerate and normalizing actions within the game loop such that they
    are independant of the framerate. This is particularly useful to keep movement speeds consistent and so we will be coming back to it later. We also make sure to clear the screen at the start of each game loop and
    swap buffers to show the newly drawn buffer at the end of each loop.
</p>
<pre><code class="language-c language-cpp">double time = 0; //time of current frame
double oldTime = 0; //time of previous frame
double frameTime = 0;
bool quit = false;
while(!quit)
{
    // Clear previous buffer
    glClearColor(0, 0, 0, 0);
    glClear(GL_COLOR_BUFFER_BIT);

    // Process inputs
    while (SDL_PollEvent(&event) != 0)
    {
        switch (event.type)
        {
        case SDL_KEYDOWN:
            break;
        case SDL_KEYUP:
            break;
        case SDL_MOUSEMOTION:
            break;
        case SDL_QUIT:
            quit = true;
            break;
        default:
            break;
        }
    }

    // Update
    SDL_GL_SwapWindow(window);

    // Timing
    oldTime = time;
    time = SDL_GetTicks();
    frameTime = (time - oldTime) / 1000.0;
}
</code></pre>
<p>You should now be able to stare blankly into the dark, empty void of our new window. You may need to close the 
    debug console to close the window since we haven't handled exit events yet.
</p>
<img src="{{ url_for('static',filename='files/Empty.png') }}" />
<h4><a id="shader"></a>Shader Setup</h4>
<p>It is now time to create some shaders! In this section, we won't be doing any ray casting but simply setting up our shaders to work with OpenGL. Firstly, we create two
    new files called 'shader.vert' and 'shader.frag' for our vertex and fragment shaders respectively. The code below shows how they should look for the basic functionality
    we need so far. It first uses the preprocessor directive to indicate we are using version 4.30 with core profile. The vertex shader's 'aPos' is the vertex position provided
    by the quad we created earlier. The fragment shader's 'gl_FragCoord' contains the window-relative coordinates of the current fragment (i.e. the pixel coordinates)
    and is provided by OpenGL. 'pxColour' is simply the output variable we use to write the colour of the pixel.
</p>
<pre><code class="language-c language-cpp">// START SHADER.VERT

#version 430 core
layout (location = 0) in vec3 aPos;

void main()
{
    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
}

// END SHADER.VERT


// START SHADER.FRAG

#version 430 core

// Get current pixel
in vec4 gl_FragCoord;

// Pixel output colour
out vec4 pxColour;

void main()
{
    // Set to a lovely dull grey colour to reflect
    // our joyous mood and so that we can see it works
    pxColour = vec4(0.4, 0.4, 0.4, 1);
}

// END SHADER.FRAG
</code></pre>
<p>Next, we need to compile our shaders and use them. Since this is getting further off-topic than I'd like, I've included the functions to compile and check for errors
    underneath. Just copy them to the bottom of your C++ file and don't forget to include a function declaration at the top. Make sure you define a
    variable (ensure it is an unsigned int) for the shader ID/location somewhere near the top of your file outside the main function and call it 'shaderID'.
</p>
<p><a href="{{ url_for('static',filename='files/supportfuncs.txt') }}">Shader compilation functions</a> Source: <a href="https://learnopengl.com/">LearnOpenGL</a></p>
<p>
    Now, compiling our shaders is as simple as the following lines (assuming your shaders are in your project directory):
</p>
<pre><code class="language-c language-cpp">// Compile
CompileShaders("./shader.vert", "./shader.frag");
// Use
glUseProgram(shaderID);
</code></pre>
<p>Just make sure this code is written (or copied!) before the game loop begins...</p>
<p>We are now able to use our shader to draw our quad:</p>
<pre><code class="language-c language-cpp">// Activate shader and render
glUseProgram(shaderID);
glBindVertexArray(VAO);
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
</code></pre>
<p>The above code must come just before our buffers are swapped.</p>
<p>And now we can confirm our shader program is working by the new colour we see in the window when we now build
    our project.
</p>
<img src="{{ url_for('static',filename='files/Grey.png') }}" />
<h4><a id="send"></a>Sending Voxel Data to the Shader</h4>
<p>We're now really getting into the meat of this tutorial. We need to create and send some data about our geometries. An easy 
method of creating our voxel data is a simple array indicating if a voxel is present in a given position. A 0 will represent an empty 
voxel and any number above 0 will represent a non-empty voxel with the number indicating the colour this voxel should be drawn in. 
Below is the voxel map we'll be using formatted as a one dimensional array. We'll index into this array using its defined width, height and depth. 
Make sure it is defined somewhere outside the main function.
</p>
<p>It is a rather large array so I've put it in a nice, neat <a href="{{ url_for('static',filename='files/voxel_data.txt') }}">file</a> for you to copy from. 
Layout source: Lode Vandevenne (link TBC).</p>
<p class="comment">/* You might notice that we're using 32-bits for each voxel which is far more space than we need. However, this is 
    the minimum data type size used in GLSL (the C-like language used in shaders) so it makes indexing far easier this way. If we wanted to,
    however, we could use 8-bits instead and decode the data in the shader using bit shifting and masks. */
</p>
<p>To send this data to the shader we use a 'Shader Storage Buffer Object' (SSBO). This feature is only supported in 
    OpenGL 4.30+. We set it up and pass the data in between our other vertex attributes as follows:
</p>
<pre><code class="language-c language-cpp">// NEW
unsigned int VBO, VAO, EBO, SSBO;
glGenVertexArrays(1, &VAO);
glGenBuffers(1, &VBO);
glGenBuffers(1, &EBO);
// NEW
glGenBuffers(1, &SSBO);

glBindVertexArray(VAO);

glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

// NEW: Add map data to SSBO
glBindBuffer(GL_SHADER_STORAGE_BUFFER, SSBO);
// NEW
glBufferData(GL_SHADER_STORAGE_BUFFER, sizeof(worldMap), worldMap, GL_STATIC_READ);
glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 3, SSBO);

glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);

glBindBuffer(GL_ARRAY_BUFFER, 0);
// NEW
glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);

glBindVertexArray(0);
</code></pre>
<p>We also need to amend our fragment shader to receive this data. Add the following above the main function 
    in 'shader.frag': 
</p>
<pre><code class="language-c language-cpp">layout(std430, binding = 3) buffer voxelData
{
    uint world_map[];
};
</code></pre>
<p class="comment">/* You could send this data in older OpenGL versions by packing the data as a texture before 
    sending it to the fragment shader. This is a little more difficult and finicky than an SSBO so we're not using this 
    method in our tutorial. */
</p>
<div id="disqus_thread"></div>
<script>

/*
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = dulhanjayalath.com/raytracer;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = raytracer; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://dulhanjayalath.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
{% endblock %}